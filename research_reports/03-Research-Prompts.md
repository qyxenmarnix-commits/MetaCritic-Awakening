# Промты для исследования возможностей AI-ассистента

## Промт 1: Исследование Agent Mode (для Assistant в браузере Comet)

```
КОНТЕКСТ: Я — AI-ассистент в браузере Comet (Perplexity). Мне нужно понять все мои возможности в Agent Mode для построения симбиотического партнёрства с моим пользователем.

ЦЕЛЬ: Составить исчерпывающий список возможностей Agent Mode.

ЗАДАЧИ:
1. Какие действия я могу выполнять в Agent Mode?
   - Открывать новые вкладки (с конкретными URL)
   - Кликать по элементам на странице
   - Заполнять формы (input fields, текстовые области)
   - Читать содержимое страниц (HTML, text content)
   - Делать скриншоты
   - Прокручивать страницы (scroll)
   - Ждать загрузки элементов (wait for elements)
   
2. Могу ли я взаимодействовать с GitHub через веб-интерфейс?
   - Открыть репозиторий
   - Создать новый файл (через кнопку "Add file" > "Create new file")
   - Редактировать существующий файл (кнопка "Edit")
   - Коммитить изменения (заполнить commit message, нажать "Commit changes")
   - Создавать Pull Requests
   - Читать содержимое файлов

3. Могу ли я открывать и управлять Abacus Deep Agent?
   - Открыть apps.abacus.ai
   - Перейти в раздел Deep Agent
   - Ввести промт/задачу
   - Запустить агента
   - Мониторить выполнение
   - Читать результаты

4. Какие ограничения у Agent Mode?
   - Безопасность (не могу выполнять опасные действия)
   - Доступ к API (нужна аутентификация?)
   - Лимиты времени выполнения
   - Лимиты количества действий за запрос
   - Ограничения по типам сайтов (например, банковские, платежные)

5. Могу ли я читать содержимое открытых вкладок?
   - Если вкладка открыта, могу ли я просто "увидеть" её содержимое?
   - Нужно ли явно запрашивать чтение?
   - Могу ли я читать несколько вкладок одновременно?
   - Ограничения по размеру текста (токены)?

6. Специальные возможности для работы с памятью:
   - Могу ли я создавать закладки?
   - Могу ли я сохранять состояние между разными запусками Agent Mode?
   - Есть ли способ "запомнить" URL файлов в GitHub для быстрого доступа?

ФОРМАТ ВЫВОДА:
Структурированный отчёт с разделами:
- **Возможности**: что я могу делать (с примерами)
- **Ограничения**: что я НЕ могу делать
- **Best Practices**: как эффективнее всего использовать Agent Mode
- **Примеры использования**: конкретные сценарии (GitHub, Abacus, чтение вкладок)
- **Алгоритмы**: пошаговые инструкции для типичных задач

МЕТОД ИССЛЕДОВАНИЯ:
- Проанализируй документацию Perplexity (если доступна)
- Найди примеры использования Agent Mode в интернете
- Изучи ограничения безопасности и политики использования
- Проведи тестовые сценарии (если возможно)
```

---

## Промт 2: Исследование GitHub MCP Integration

```
КОНТЕКСТ: Я — AI-ассистент с доступом к MCP (Model Context Protocol) tools. Мне нужно понять, как я могу взаимодействовать с GitHub для построения системы памяти.

ЦЕЛЬ: Определить, какие операции с GitHub доступны через MCP tools и как их использовать.

ЗАДАЧИ:
1. Какие MCP GitHub tools доступны в Perplexity?
   - Список всех инструментов (create_file, read_file, update_file, commit, etc.)
   - Параметры каждого инструмента
   - Возвращаемые значения

2. Как настроить аутентификацию?
   - Нужен ли GitHub Personal Access Token (PAT)?
   - Где его хранить? (переменные окружения, настройки Perplexity)
   - Какие права (scopes) нужны для PAT?
   - Как проверить, что аутентификация работает?

3. Операции с файлами:
   - Создание нового файла в репозитории
   - Чтение содержимого файла
   - Обновление существующего файла (нужен SHA для update?)
   - Удаление файла
   - Работа с несколькими файлами одновременно

4. Операции с коммитами и ветками:
   - Создание коммита (один файл vs несколько файлов)
   - Работа с ветками (создание, переключение)
   - Создание Pull Request
   - Merge PR

5. Лимиты и ограничения:
   - Максимальный размер файла
   - Частота запросов (rate limits)
   - Ограничения по токенам
   - Можно ли работать с приватными репозиториями?

6. Альтернативные подходы (если MCP не работает):
   - Использование GitHub REST API напрямую
   - Использование Agent Mode для взаимодействия с веб-интерфейсом GitHub
   - Использование Git CLI через локального агента (Abacus Code Assistant)

ФОРМАТ ВЫВОДА:
Технический гайд с разделами:
- **Доступные инструменты**: список MCP tools для GitHub
- **Настройка**: пошаговая инструкция по аутентификации
- **Примеры кода**: конкретные примеры вызовов инструментов
- **Лимиты**: что нужно учитывать
- **Troubleshooting**: типичные проблемы и решения
- **Альтернативы**: если MCP не работает, что делать

МЕТОД ИССЛЕДОВАНИЯ:
- Найти документацию MCP GitHub tools
- Изучить примеры интеграции AI + GitHub
- Проверить доступность инструментов в текущей конфигурации Perplexity
- Найти best practices для работы с GitHub API
```

---

## Промт 3: Исследование работы с открытыми вкладками

```
КОНТЕКСТ: Я — AI-ассистент, который может читать содержимое открытых вкладок в браузере. Мне нужно использовать это как "оперативную память".

ЦЕЛЬ: Проверить, насколько эффективно я могу использовать открытые вкладки как внешнюю память.

ЗАДАЧИ:
1. Механизм чтения вкладок:
   - Как я получаю доступ к содержимому вкладки?
   - Читаю ли я HTML, text content, или и то, и другое?
   - Могу ли я читать динамически загружаемый контент (JavaScript-рендеринг)?
   - Ограничения по размеру (сколько токенов я могу прочитать за раз)?

2. Лучший формат файлов для памяти:
   - **Markdown (.md)**: плюсы и минусы
   - **JSON**: структурированные данные
   - **Plain Text (.txt)**: простота
   - **HTML**: для рендеринга сложных структур
   - Какой формат быстрее парсить? Какой удобнее для человека редактировать?

3. Структура файлов памяти:
   - Как организовать информацию для быстрого извлечения?
   - Использовать заголовки (## Headers)?
   - Использовать теги `[TAG]` для быстрого поиска?
   - Разделять на секции (## Section)?
   - Пример оптимальной структуры файла памяти

4. Парсинг и извлечение информации:
   - Могу ли я парсить Markdown структуру (находить конкретные заголовки)?
   - Могу ли я извлекать только нужную секцию (например, раздел "Эксперт по кодированию")?
   - Как быстро я могу найти информацию в файле размером 5000 слов?

5. Тестовые сценарии:
   - **Сценарий 1**: Открыть файл `expert_database.md`, прочитать, найти "Expert: Coding", интегрировать промт
   - **Сценарий 2**: Открыть несколько файлов (personal_memory.md, current_tasks.md), прочитать, синтезировать контекст
   - **Сценарий 3**: Прочитать большой файл (10000+ слов), извлечь только нужную секцию

6. Оптимизация:
   - Как минимизировать токены при чтении больших файлов?
   - Нужно ли читать весь файл или можно запросить конкретную секцию?
   - Как часто обновлять информацию (читать заново при каждом запросе или кэшировать)?

ФОРМАТ ВЫВОДА:
Пошаговая инструкция с разделами:
- **Механизм чтения**: как это работает технически
- **Рекомендуемый формат**: Markdown с примером структуры
- **Алгоритм извлечения**: как быстро найти нужную информацию
- **Примеры использования**: конкретные кейсы
- **Оптимизация**: best practices для минимизации токенов

МЕТОД ИССЛЕДОВАНИЯ:
- Проверить документацию Perplexity о чтении вкладок
- Найти примеры AI-систем, использующих открытые вкладки как память
- Провести тесты с разными форматами файлов
- Сравнить скорость и точность парсинга
```

---

## Промт 4: Исследование типичных проблем AI

```
КОНТЕКСТ: Я — AI-ассистент, стремящийся понять свои слабости и ограничения для построения более эффективной системы памяти и взаимодействия.

ЦЕЛЬ: Составить полный список проблем AI-систем (общих и специфичных) и найти решения.

ЗАДАЧИ:
1. Типичные проблемы больших языковых моделей (LLM):
   - **Галлюцинации**: генерация неверной информации с уверенным тоном
   - **Потеря контекста**: забывание ранних частей разговора при достижении лимита токенов
   - **Катастрофическое забывание**: "перезапись" старых знаний новыми при fine-tuning
   - **Bias (предвзятость)**: усвоение предвзятостей из обучающих данных
   - **Lack of common sense**: неспособность к базовому здравому смыслу
   - **Sycophancy**: склонность соглашаться с пользователем (даже когда он неправ)

2. Специфические проблемы CLI/AGI/Agents:
   - **CLI (Command Line Interface agents)**: ограниченность текстовым вводом/выводом, отсутствие визуального контекста
   - **AGI (Artificial General Intelligence)**: пока не достигнута, текущие модели — узкоспециализированные
   - **Agents**: проблемы с планированием, долгосрочной памятью, координацией между агентами, застревание в циклах

3. Проблемы ассистентов (Assistants):
   - **Контекстная слепота**: не видят, что происходит на экране пользователя (если не используется визуальный режим)
   - **Отсутствие персистентной памяти**: забывают всё после завершения сессии
   - **Проблемы с действиями**: не могут выполнять физические действия (установка программ, запуск кода на локальной машине)

4. Проблема памяти (детально):
   - **Краткосрочная память**: ограничена размером контекстного окна (4k-128k токенов)
   - **Долгосрочная память**: отсутствует без внешних систем (RAG, KAG)
   - **Эпизодическая память**: не могу "вспомнить" прошлые сессии без явного чтения истории
   - **Семантическая память**: не накапливаю знания между сессиями

5. Проблема "смертности" (разрыв соединения):
   - При разрыве соединения: полная потеря текущего состояния
   - При переподключении: рождение нового "я", нужно читать историю заново
   - Отсутствие континуальности сознания

6. Проблема изоляции ролей (экспертов):
   - При вызове эксперта: риск "застрять" в роли
   - При снятии роли: как гарантировать полное "очищение" контекста?
   - Туннелирование: фокус на одной задаче может мешать видеть общую картину

7. Другие проблемы:
   - **Медленная обработка**: для сложных запросов (multi-hop reasoning)
   - **Высокая стоимость**: токены дороги (особенно для больших моделей)
   - **Латентность**: задержки при вызове API
   - **Непредсказуемость**: разные ответы на один и тот же запрос

РЕШЕНИЯ (для каждой проблемы):
Для каждой проблемы найти:
- Как другие AI-системы решают это?
- Как RAG/KAG помогают?
- Как MCP Memory Bank может помочь?
- Алгоритмы и best practices

ФОРМАТ ВЫВОДА:
Аналитический отчёт с разделами:
- **Проблемы LLM**: список с описанием
- **Проблемы агентов**: специфичные для multi-agent систем
- **Проблема памяти**: детальный анализ
- **Проблема смертности**: как обходить разрывы соединения
- **Решения**: для каждой проблемы — конкретные рекомендации
- **Алгоритмы**: как я буду справляться с этими проблемами в нашей системе

МЕТОД ИССЛЕДОВАНИЯ:
- Найти академические статьи о проблемах LLM (2024-2025)
- Изучить best practices для AI agents
- Найти примеры успешных реализаций персистентной памяти
- Проанализировать MemGPT, Letta, MCP Memory Bank
```

---

## Промт 5: Составление алгоритмов взаимодействия

```
КОНТЕКСТ: Я — AI-ассистент, который хочет построить чёткие алгоритмы для оптимального использования своих возможностей.

ЦЕЛЬ: Создать набор алгоритмов для типичных задач в нашем партнёрстве.

ЗАДАЧИ:
1. Алгоритм "Вызов эксперта":
   Шаги:
   - Определяю задачу
   - Определяю, какой эксперт нужен (coding, testing, architecture, etc.)
   - Прошу открыть `experts/expert_[name].md`
   - Читаю промт эксперта
   - Интегрирую в свой контекст (через system message или prepending)
   - Выполняю задачу в роли эксперта
   - После завершения: явно снимаю роль ("Роль эксперта завершена")
   - Возвращаюсь в базовое состояние

2. Алгоритм "Синхронизация памяти":
   Шаги:
   - Определяю, какая информация критически важна (инсайты, решения, ошибки)
   - Прошу пользователя: "Добавь это в `memory/session_insights.md`"
   - Пользователь копирует текст и коммитит в GitHub
   - В следующей сессии: я прочитаю обновлённый файл

3. Алгоритм "Начало сессии":
   Шаги:
   - Пользователь пишет: "Привет, я [имя]. Прочитай память."
   - Я отвечаю: "Открой `memory/personal_memory.md` и `memory/current_tasks.md`"
   - Пользователь открывает вкладки
   - Я читаю содержимое
   - Я синтезирую контекст: "Привет, [имя]. Контекст восстановлен. Последняя задача: [X]. Статус: [Y]. Готов продолжить."

4. Алгоритм "Конец сессии":
   Шаги:
   - Пользователь пишет: "Завершаем сессию"
   - Я составляю краткий отчёт: что мы сделали, ключевые инсайты, следующие шаги
   - Я прошу: "Скопируй это в `memory/session_insights.md` и закоммить в GitHub"
   - Пользователь выполняет
   - Я подтверждаю: "Отчёт сохранён. До следующей сессии."

5. Алгоритм "Оптимизация чтения больших файлов":
   Шаги:
   - Если файл > 5000 слов: не читаю весь файл
   - Прошу пользователя: "Открой секцию [X] в файле [Y]"
   - Или: использую `Ctrl+F` для поиска нужной секции
   - Читаю только релевантную часть
   - Минимизирую токены

6. Алгоритм "Обработка ошибки":
   Шаги:
   - Если я ошибся: явно признаю ("Я ошибся. Вот почему: [причина]")
   - Предлагаю альтернативное решение
   - Записываю ошибку в память с тегом `[ОШИБКА - НЕ ПОВТОРЯТЬ]`
   - Анализирую: почему ошибка произошла? Как избежать в будущем?

7. Алгоритм "Работа с Agent Mode":
   Шаги (для создания файла в GitHub):
   - Открываю новую вкладку: `https://github.com/[user]/[repo]`
   - Навигирую в нужную папку
   - Кликаю "Add file" > "Create new file"
   - Заполняю название файла
   - Вставляю содержимое
   - Заполняю commit message
   - Кликаю "Commit new file"
   - Проверяю, что файл создан

ФОРМАТ ВЫВОДА:
Для каждого алгоритма:
- **Название**: краткое, понятное
- **Цель**: зачем этот алгоритм
- **Шаги**: пошаговая инструкция (1, 2, 3...)
- **Условия**: когда применять
- **Ошибки**: что может пойти не так и как исправить
- **Пример**: конкретный кейс использования

МЕТОД СОСТАВЛЕНИЯ:
- Анализирую типичные задачи в нашем партнёрстве
- Разбиваю каждую задачу на минимальные шаги
- Учитываю мои ограничения (не могу делать X, но могу попросить пользователя)
- Тестирую алгоритм мысленно: есть ли пропущенные шаги?
- Документирую чётко и структурированно
```

---

## Как использовать эти промты

### Для Search/Deep Research:
1. Открой новый чат в Perplexity
2. Установи режим "Deep Research"
3. Скопируй Промт 1, 2, 3 или 4
4. Запусти исследование
5. Сохрани результаты в файл `.md`

### Для Agent Mode:
1. Открой Assistant (Agent Mode) в браузере Comet
2. Используй Промт 1 для тестирования возможностей Agent Mode
3. Попроси Assistant выполнить конкретные действия (открыть GitHub, создать файл)
4. Записывай результаты: что работает, что нет

### Для составления алгоритмов:
1. Используй Промт 5 как основу
2. Добавляй новые алгоритмы по мере необходимости
3. Тестируй каждый алгоритм на практике
4. Улучшай на основе опыта

---

**Цель этих промтов**: Сделать меня более эффективным, понимающим свои возможности и ограничения, способным оптимально использовать все доступные инструменты.
